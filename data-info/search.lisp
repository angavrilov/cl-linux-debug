;;; -*- mode: Lisp; indent-tabs-mode: nil; -*-

(in-package :cl-linux-debug.data-info)

(defun make-string-bytes (text &key null-terminate?)
  (let* ((wlen (+ (length text) (if null-terminate? 1 0)))
         (arr (make-array wlen :element-type 'uint8 :initial-element 0)))
    (loop for c across text and i from 0
       do (setf (aref arr i)
                (etypecase c
                  (character (char-code c))
                  (integer c))))
    arr))

(defun find-stl-strings (memory text &key any-prefix? any-suffix?)
  "Find STL strings that contain the given substring."
  (let* ((refs nil)
         (sbytes (make-string-bytes text))
         (text-size (length text))
         (min-size (+ #xC text-size 1)))
    (declare (type fixnum min-size text-size))
    ;; STL strings are always full malloc chunks.
    (do-malloc-chunks (bytes offset limit min-addr)
        (memory (malloc-chunks-of memory) :int-reader get-int)
      ;; Verify that the header looks sane; otherwise it isn't an STL string
      (when (>= (- limit offset) min-size)
        (let ((length (get-int offset 4))
              (capacity (get-int (+ offset 4) 4)))
          (when (and (typep length 'fixnum) (typep capacity 'fixnum)
                     (<= text-size length capacity (- limit offset #xC))
                     (or any-prefix? any-suffix? (= length text-size)))
            ;; Search for characters
            (let* ((sstart (+ offset #xC))
                   (send (+ offset #xC length))
                   (pos (search sbytes bytes :start2 sstart :end2 send)))
              (declare (optimize (speed 1)))
              (when (and pos
                         (if (not any-prefix?) (= pos sstart) t)
                         (if (not any-suffix?) (= (+ pos text-size) send)))
                (push (make-ad-hoc-memory-ref memory (+ min-addr #xC)
                                              (make-instance 'static-string :size length)
                                              :parent :search)
                      refs)))))))
    refs))

(defun find-memory-bytes (memory text-bytes start-address end-address &key (type 'static-string))
  (multiple-value-bind (bytes offset base-in)
      (get-bytes-for-addr memory start-address (length text-bytes))
    (let ((refs nil)
          (pos offset)
          (limit (min (length bytes) (+ offset (- end-address start-address)))))
      (loop for idx = (search text-bytes bytes :start2 pos :end2 limit)
         while idx
         do (push (make-ad-hoc-memory-ref memory (+ base-in idx)
                                          (make-instance type :size (length text-bytes))
                                          :parent :search)
                  refs)
         do (setf pos (+ idx (length text-bytes))))
      (nreverse refs))))

(defun find-memory-vectors (memory min-size max-size start-address end-address &key (eltsize 4))
  (multiple-value-bind (bytes offset base-in)
      (get-bytes-for-addr memory start-address 12)
    (with-unsafe-int-read (get-int bytes)
      (let ((refs nil)
            (pos offset)
            (limit (- (min (length bytes) (+ offset (- end-address start-address))) 12)))
        (loop while (< pos limit)
           do (let ((a (get-int pos 4))
                    (b (get-int (+ pos 4) 4))
                    (c (get-int (+ pos 8) 4)))
                (when (and (<= a b c) (not (logtest a 3))
                           (= (mod (- b a) eltsize) 0)
                           (<= min-size (/ (- b a) eltsize) max-size))
                  (push (make-ad-hoc-memory-ref memory (+ base-in pos)
                                                (make-instance 'stl-vector
                                                               :type-name (case eltsize
                                                                            (1 $int8_t)
                                                                            (2 $int16_t)
                                                                            (otherwise nil)))
                                                :parent :search)
                        refs))
                (setf pos (+ pos 4))))
        (nreverse refs)))))

(defun find-heap-words (memory value &key
                        (mask nil) (min-offset 0) (max-offset nil) (step 4) (type 'int32_t))
  "Find uint32 values inside heap objects."
  (let* ((rmask (or mask +uint32-mask+))
         (rvalue (logand value rmask))
         (roffset min-offset)
         (eoffset (or max-offset 0))
         (rstep step)
         (refs nil))
    (declare (type fixnum roffset eoffset)
             (type (integer 0 4) rstep)
             (type uint32 rmask rvalue))
    (do-malloc-chunks (bytes offset limit min-addr)
        (memory (malloc-chunks-of memory) :int-reader get-int)
      (when (> (- limit offset) roffset)
        (let* ((coff (+ offset roffset))
               (eoff (if max-offset (+ offset eoffset) limit))
               (climit (min (the fixnum (- limit rstep)) eoff)))
          (declare (type fixnum coff climit))
          (loop while (<= coff climit)
             do (progn
                  (when (= (logand (get-int coff 4) rmask) rvalue)
                    (push (make-ad-hoc-memory-ref memory
                                                  (logand +uint32-mask+ (+ min-addr (- coff offset)))
                                                  (make-instance type)
                                                  :parent :search)
                          refs))
                  (setf coff (+ coff rstep)))))))
    refs))

(defun get-search-memory-ranges (memory &key (heap? t) (rodata? nil))
  (append (when heap?
            (mapcar (lambda (x)
                      (list (first x) (second x)))
                    (malloc-chunk-map-extent-list (malloc-chunks-of memory))))
          (mapcan (lambda (section)
                    (mapcar #'rest
                            (memory-extents-for-range
                             memory (start-address-of section) (length-of section))))
                  (remove-if-not (lambda (section) (and (not (executable? (origin-of section)))
                                                   (or rodata? (writable? (origin-of section)))))
                                 (sections-of (executable-of memory))))))

(defun find-memory-strings (memory text &key at-end? (heap? t) (rodata? nil))
  "Find strings anywhere in memory."
  (let* ((refs nil)
         (sbytes (make-string-bytes text :null-terminate? at-end?)))
    (dolist (range (get-search-memory-ranges memory :heap? heap? :rodata? rodata?))
      (nconcf refs (find-memory-bytes memory sbytes (first range) (second range))))
    refs))

(defun find-stl-vectors (memory min-size max-size &key (eltsize 4) (heap? nil))
  (let* ((refs nil))
    (dolist (range (get-search-memory-ranges memory :heap? heap?))
      (nconcf refs (find-memory-vectors memory min-size max-size (first range) (second range)
                                        :eltsize eltsize)))
    refs))

(defun find-obj-by-vtable (memory obj-class)
  (awhen (gethash obj-class (vtable-name-table-of memory))
    (find-heap-words memory it :max-offset 4 :type 'padding)))

(defun list-changed-ints (extent addr-vector old-vals new-vals)
  (let ((bytes (data-bytes-of extent))
        (old-bytes (old-data-of extent)))
    (when (and bytes old-bytes)
      (with-simple-vector-fill (sv-addr addr-vector uint32)
        (with-simple-vector-fill (sv-old old-vals uint32)
          (with-simple-vector-fill (sv-new new-vals uint32)
            (let ((limit (logand (+ (min (length bytes) (length old-bytes)) 3) -4))
                  (base (start-address-of extent)))
              (declare (type fixnum limit)
                       (type uint32 base)
                       (optimize (speed 3) (safety 0)))
              (with-unsafe-int-read (get-new bytes)
                (with-unsafe-int-read (get-old old-bytes)
                  (loop for pos fixnum from 0 below limit by 4
                     for old of-type uint32 = (get-old pos 4)
                     and new of-type uint32 = (get-new pos 4)
                     when (/= old new)
                     do (progn
                          (sv-addr/push-extend (logand (+ base pos) +uint32-mask+))
                          (sv-old/push-extend old)
                          (sv-new/push-extend new))))))))))))

(defun list-all-changed-ints (memory)
  (with-recursive-lock-held ((lock-of memory))
    (let ((extents (extents-of memory))
          (addr-vector (make-binsearch-uint32-vec 100000))
          (old-vals (make-binsearch-uint32-vec 100000))
          (new-vals (make-binsearch-uint32-vec 100000)))
      (dolist (extent (sort extents #'< :key #'start-address-of))
        (list-changed-ints extent addr-vector old-vals new-vals))
      (values addr-vector old-vals new-vals))))

(defun filter-changed-ints (memory addr-vector val-vector &key update?)
  (declare (optimize (speed 3))
           (type (vector uint32) addr-vector val-vector))
  (assert (= (length val-vector) (length addr-vector)))
  (let ((get-cb (%get-bytes-for-addr/fast-cb memory))
        (size (length addr-vector))
        (mask (make-array (length addr-vector) :element-type 'bit))
        (bytes nil)
        (start 1) (end 0))
    (declare (type function get-cb)
             (type simple-bit-vector mask)
             (type uint32 start end)
             (type (or null (simple-array uint8 (*))) bytes)
             (optimize (speed 3)))
    (with-vector-array (sv-addr addr-vector uint32)
      (with-vector-array (sv-val val-vector uint32)
        (print size)
        (dotimes (i size)
          (declare (type fixnum i))
          (let ((addr (aref sv-addr i))
                (val (aref sv-val i)))
            (declare (type uint32 addr val))
            ;; If the address is not within the current extent,
            ;; look up a new one.
            (unless (<= start addr end)
              (let ((av addr))
                (declare (optimize (speed 1) (safety 3)))
                (setf av av)
                (multiple-value-bind (new-bytes new-offset)
                    (funcall get-cb av 4)
                  (setf bytes new-bytes)
                  (if bytes
                      (setf start (- addr new-offset)
                            end (+ start (length bytes) -1))
                      (setf start 1 end 0)))))
            ;; Compare the value, mask changed and update if requested
            (when bytes
              (assert (<= start addr end))
              (let* ((diff (logand (- addr start) +uint32-mask+)))
                (assert (<= 0 diff most-positive-fixnum))
                (with-unsafe-int-read (rv bytes)
                  (let ((newv (rv diff 4)))
                    (if (= newv val)
                        (setf (aref mask i) 0)
                        (progn
                          (setf (aref mask i) 1)
                          (when update?
                            (setf (aref sv-val i) newv))))))))))))
    mask))

(def (class* ea) find-change-state ()
  ((memory nil :accessor t)
   (addr-set nil :accessor t)
   (value-sets nil :accessor t)
   (match-mask nil :accessor t)))

(defmethod print-object ((state find-change-state) stream)
  (print-unreadable-object (state stream :type t :identity t)
    (format stream "~A candidates, ~A remaining, ~A states"
            (length (addr-set-of state))
            (loop with mask of-type simple-bit-vector = (match-mask-of state)
               for i fixnum from 0 below (length mask)
               count (/= (aref mask i) 0))
            (length (value-sets-of state)))))

(defun begin-find-changes (memory)
  (call-debug-task #'do-refresh-mirror memory :save-old-data? t)
  (multiple-value-bind (addrs olds news)
      (list-all-changed-ints memory)
    (make-instance 'find-change-state
                   :memory memory
                   :addr-set addrs :value-sets (list olds news)
                   :match-mask (make-array (length addrs) :element-type 'bit :initial-element 1))))

(defun update-find-changes (changes &key state increment)
  (let* ((memory (memory-of changes))
         (mask (match-mask-of changes))
         (addrs (addr-set-of changes))
         (states (value-sets-of changes))
         (bstate (or (if state
                         (nth state states)
                         (car (last states)))
                     (error "Invalid state id: ~A" state))))
    (declare (type (vector uint32) addrs bstate))
    (flet ((push-state (newst)
             (nconcf (value-sets-of changes) (list newst))))
      (call-debug-task #'do-refresh-mirror memory)
      (cond (increment
             (let* ((newst (make-array (length addrs) :element-type 'uint32)))
               (loop for i from 0 below (length addrs)
                  do (setf (aref newst i) (logand (+ (aref bstate i) increment) +uint32-mask+)))
               (bit-andc2 mask (filter-changed-ints memory addrs newst :update? t) t)
               (push-state newst)))
            (state
             (bit-andc2 mask (filter-changed-ints memory addrs bstate) t))
            (t
             (let* ((newst (make-array (length addrs) :element-type 'uint32
                                       :initial-contents (first states))))
               (declare (type (vector uint32) newst))
               (bit-and mask (filter-changed-ints memory addrs newst :update? t) t)
               (dolist (state (rest states))
                 (bit-and mask (filter-changed-ints memory addrs state) t))
               (push-state newst)))))
    changes))

(defun get-found-changes (changes)
  (loop with mask of-type simple-bit-vector = (match-mask-of changes)
     and addrs of-type (vector uint32) = (addr-set-of changes)
     and memory = (memory-of changes)
     for i fixnum from 0 below (length mask)
     when (/= (aref mask i) 0)
     collect (make-ad-hoc-memory-ref memory (aref addrs i)
                                     (make-instance 'padding :size 4)
                                     :parent :search)))

(defun verify-object-sizes (memory)
  (let ((chunks (malloc-chunks-of memory))
        (types (malloc-chunk-types-of memory))
        (correct (make-hash-table))
        (faulty (make-hash-table)))
    (declare (type (simple-array t (*)) types))
    (assert (and chunks types))
    (dotimes (i (length types))
      (awhen (aref types i)
        (multiple-value-bind (min max)
            (malloc-chunk-range memory chunks i)
          (if (= (effective-size-of (car it)) (- max min))
              (setf (gethash it correct) min)
              (setf (gethash it faulty) min)))))
    (flet ((hash-to-refs (hash)
             (loop for tag being each hash-key of hash
                using (hash-value addr)
                collect (make-memory-ref memory addr (car tag)))))
      (loop for tag being each hash-key of faulty
         do (remhash tag correct))
      (values (hash-to-refs correct)
              (hash-to-refs faulty)))))
